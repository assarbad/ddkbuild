If you are interested in how DDKBUILD.CMD ticks, read on. Otherwise use theDDKWizard manual to find out how to configure your system and Visual Studio foruse with DDKBUILD and use the help output (call DDKBUILD without parameters) tofind out more about its command line options.First off, DDKBUILD.CMD was indeed a complete rewrite of DDKBUILD.BAT from OSRusing the advanced possibilities of the NT script interpreter. Thus, even thoughthe command line options are mostly compatible, many of the internals of bothscripts are quite different.In this little README file I want to address some of the tricks used during tomake DDKBUILD.CMD work just the way it works. However, I will not describe basicconcepts of NT shell scripting but rather those that set DDKBUILD.CMD apart.Perhaps DDKBUILD.CMD is one of the biggest scripts ever written for the NTscript interpreter.USED TECHNIQUES:================1. Hiding information and hiding errors---------------------------------------   While undoubtedly one of the fundamental uses of DDKBUILD is as a wrapper of   the BUILD utility from the DDK, there are things to do before and after   calling. Some of these things involve ugly messages that be better hidden   from the end user.   As an example we can have a look at the code that tries to check whether the   FINDSTR utility is available on the user's system.      findstr /? > NUL 2>&1 || echo "Error" && goto :EOF      This line is pretty simple and and any Bash afiniciados might already be able   to decipher it without further comment. The part before the two pipe   characters attempts to call FINDSTR and redirects its STDOUT as well as   STDERR to NUL (which, btw, is the name of a file in every single directory on   a Windows system). "2>&1", similar to the Bash syntax actually says to   redirect STDERR (handle 2) to the same pipe as STDOUT (handle 1).      The two consecutive pipe characters tell the script interpreter to only run   the code to the right of it if the ERRORLEVEL variable (i.e. the exit code of   the attempted execution of FINDSTR) is zero. This means that the command left   of those pipe characters executed successfully. This trick also works for   most other commands/executables and in fact DDKBUILD uses it to check whether   the REG.EXE utility is available. While existent in Windows XP, on some   Windows 2000 systems it is only part of the supplementary tools from the   install CD.2. Use :: instead of REM------------------------   REM, meaning "remove", denotes a comment line in batch scripts and is also   available in NT scripts for compatibility reasons. However, in NT scripts you   have the option of using the more readable syntax with :: instead.      Using :: to start a line makes the whole script more readable because it is   more distinct from other commands that are usually comprised of words or   parts of words (call them mnemonics if you like). REM just looks like any   other command and therefore you are often at a loss in long scripts if your   editor doesn't have syntax highlighting for NT scripts.      Sadly though, many editors even now more than a decade after Windows NT 4.0   was released do not support proper syntax highlighting for this kind of   comments.   3. Using subroutines--------------------   Just like with real programming languages, GOTO is usually  not the way to   do things anymore, although it is often more convenient than not using it.      I suggest you get and read the book "NT Shell Scripting" for a primer on how   to use subroutines in batch and NT scripts. The CALL command can not just be   used to call external batch scripts (if you simply called and external script   without CALL, the execution could potentially get stuck in the other script   and not return). CALL can also be used to call subroutines - aka "labels" -   similar to the way you can use GOTO.      If you define a particular label and end its execution path by a "GOTO :EOF",   the latter one can be used in the same way as "return" in other languages.      There is only a minor caveat with this approach in that the flow of execution   *before* any subroutines has to be ended by "GOTO :EOF" as well, because it   would otherwise run into the first of the subroutines.      Furthermore subroutines take their own set of parameters that can be   addressed using the variables %1 through %9 and used within the routine using   the syntax described under "FOR /?", such as "%~1" in order to remove the   outer double quotes from the parameter. This is a pretty neat feature for   normalization of parameters or processing of file names.  TBD.